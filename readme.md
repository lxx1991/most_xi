## 算法

题目要求在给定的字符串流中找到所有长度不超过N的$m$的倍数. 假设给的序列为$\{x_{i}\}$, 那么问题等价于找到所有的$i$, $j$满足：

$$\begin{cases}
\sum_{k=1}^i x_{k}*10^{j-k} \equiv \sum_{k=1}^j x_{k}*10^{j-k}\ \mod m
\\ j - i > 0
\\ j - i \leq N
\end{cases}$$

这里不妨假设M和10互质, 那么容易通过扩展欧几里得算法找到$r$, 使得 $r * 10 \equiv 1 \mod m$. 第一个式子可以等价为：

$$\sum_{k=1}^i x_{k}*10^{j-k} * r^{j} \equiv \sum_{k=1}^j x_{k}*10^{j-k}*r^{j}\ \mod m$$

即

$$\sum_{k=1}^i x_{k}*r^{k} \equiv \sum_{k=1}^j x_{k}*r^{k}\ \mod m$$

即原题目等价于找到所有的$i$, $j$满足：

$$\begin{cases}
\sum_{k=1}^i x_{k}*r^{k} \equiv \sum_{k=1}^j x_{k}*r^{k}\ \mod m
\\ j - i > 0
\\ j - i \leq N
\end{cases}$$

因此我们只需要在收到数据的过程中实时计算序列 $y_i=\sum_{k=1}^i x_{k}*r^{k}\ \mod m$, 并且检查$y_{i-1}$到$y_{i-N}$是否有相同的值即可. 整个事情容易用hash来实现做到O(1)(很小的概率会漏掉某些答案).

如果M和10不互质得想想办法
- 预赛的M1可以替换成M1/2，最后检查结果是不是偶数
- 预赛的M4可以只保留3,7约数，辅助以后k位是否合法做检查判断(后k位可能的组合非常少，可以打表判断)
- 决赛的M1可以替换成M1/10，最后检查结果是不是0结尾
- ...


## 优化细节

1. 首先猜测服务器端应该是先随机生成位数l,然后生成一个l位数k,最后在随机字符串中插入k*M.在这个前提下,M3和M4可以用他们的一个大约数替换,极小概率出错且全程不需要高精度(预赛的时候测试过基本没问题)\\
    - M1 用了2022021721441 和判断0结尾
    - M2 用 __uint128_t 正常算
    - M3 用了500000000000000209,同时判断答案位数大于等于54
    - M4 用了244210137401840841,同时判断答案位数大于等于71

2. 可以利用两次信息之间的间隔做预处理来加速下次的计算(去掉关键路径上的mod运算), 这里提供两个办法(程序里选了第二种)：
    - 若当前处理到第i位，假设服务器一次发送的串最长位L. 那么我们可以在间隔的时候算好所有的 $\{0..9\} * r^{k}\ \mod m(i<k \le i+L)$ , 下次数据到的时候查表求和即可.
    - 由于答案不超过N, 因此我们可以每次只保留串的最后N位重新做初始化. 假设服务器一次发送的串最长位L, 那么我们的k的取值只有0到N+L, 即我们可以预处理好所有的 $\{0..9\} * r^{k}\ \mod m(0 \le k \le N+L)$

3. 基于1的猜想, 可以预测某些答案. 具体为枚举在当前串后面如果补最多k个数字(为了正确率k最长为M位数减8),是否能构成M的倍数,如果可以直接输出. 预测用了boost算高精度,因为速度较慢需要放在正式工作做完之后.

4. 网络
    - 接受的socket非阻塞, 建立多个连接同时收, 用最快的那个信息
    - 根据一轮的答案数, 建立多个连接避免排队, 保持长连接, 尽量不重连

5. minor
    - hash用2次幂大小的数组实现, 直接位运算找位置
    - 如果当前位置是答案, 检查后续字符是不是0, 若是0也是答案直接发出
    - 田忌赛马, 因为M2用了__uint128_t算的慢, 因此计算顺序改成M1,M3,M4,M2

## 运行

编译：g++ final.cpp -o final -O3

运行：while true; do ./final; sleep 2; done

## 其他

感谢陈宇同学前一次比赛程序，让我免去网络连接部分的调试